'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // API methods


var _fetch = require('./fetch');

var _fetch2 = _interopRequireDefault(_fetch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Simple replacement for Bluebird's Promise.mapSeries() implementation
 * @param {Array} tasks to run serially
 * @param {Function} task function to execute
 * @return {Promise}
 */
function sequence(tasks, fn) {
  return tasks.reduce(function (promise, task) {
    return promise.then(function () {
      return fn(task);
    });
  }, Promise.resolve());
}

/**
 * API class, has a function for each method of the Telegram API which take
 * an object argument, and send request to the API server
 *
 * Methods: getMe, sendMessage, forwardMessage, sendPhoto, sendAudio,
 * sendDocument, sendSticker, sendVideo, sendLocation, sendChatAction,
 * getUserProfilePhotos, getUpdates
 *
 */

var API = function () {
  /**
   * Create a new api object with the given token
   * @param  {string} token
   */
  function API(token) {
    _classCallCheck(this, API);

    this.token = token;
    this._queue = [];
    this._inUseQueue = [];
  }

  /**
   * Run Telegram API calls serially using internal queueing mechanism
   * @private
   */


  _createClass(API, [{
    key: '_runQueue',
    value: function _runQueue() {
      var _this = this;

      // implementation taken from https://github.com/yagop/node-telegram-bot-api/issues/192#issuecomment-249488807
      if (this._inUseQueue.length || !this._queue.length) return;

      this._inUseQueue = this._queue;
      this._queue = [];

      sequence(this._inUseQueue, function (request) {
        //eslint-disable-line
        return _this.request(request.method, request.data).then(request.resolve).catch(request.reject);
      }).then(function () {
        _this._inUseQueue = [];
        _this._runQueue();
      });
    }
  }]);

  return API;
}();

exports.default = API;


API.prototype.request = function request(method, data) {
  return (0, _fetch2.default)(this.token + '/' + method, data);
};

var methods = ['getMe', 'sendMessage', 'forwardMessage', 'sendPhoto', 'sendAudio', 'sendDocument', 'sendSticker', 'sendVideo', 'sendLocation', 'sendChatAction', 'getUserProfilePhotos', 'getUpdates', 'setWebhook', 'deleteMessage'];

methods.forEach(function (method) {
  API.prototype[method] = function (data) {
    var _this2 = this;

    //eslint-disable-line
    if (method === 'getUpdates') {
      // don't add 'getUpdates' request to the queue as it's going to
      // hinder 'send*' calls performance
      return this.request(method, data);
    }

    // implementation taken from https://github.com/yagop/node-telegram-bot-api/issues/192#issuecomment-249488807
    return new Promise(function (resolve, reject) {
      _this2._queue.push({ method: method, data: data, resolve: resolve, reject: reject });
      process.nextTick(_this2._runQueue.bind(_this2));
    });
  };
});
module.exports = exports['default'];
